# 材质详解：

## 材质纹理详解：

**纹理尺寸：** 一般是2的幂次，涉及到关于材质闪烁的原因：Mipmap；

**材质压缩**： 直接导入PSD文件，然后在材质贴图细节选项，在细节，材质纹理表达式中选择对应的遮罩，比如法线对法线；如果是灰度贴图，就使用Mask/Alpha(更小)/BC7(最高)：

**RGBA**: 图像通道；

**前向渲染和延迟渲染**： 光栅化：所有屏幕可见都会被绘制位屏幕的像素，一般是三角形构成；

## 一、什么是前向渲染

**定义：**

前向渲染是一种渲染方式，直接在渲染管线的“前端”对场景中的每个几何体（通常是三角形）逐个像素进行光照和着色的计算，然后输出最终像素颜色的技术。

**核心思想：**

- 遍历场景中的每个几何体（模型）
- 对每个几何体的每个片段（片段：像素的潜在候选）
- 计算该片段的颜色（基色）和光照信息（如阴影、光源反应）
- 最终将颜色写入帧缓冲区（渲染到屏幕）

---

## 二、前向渲染的原理

### 1. 渲染流程

- **几何渲染：** 将场景中的模型投影到屏幕上，形成三角形的片段（Fragments）。
- **光照计算：** 对每个片段，考虑场景中的光源（点光源、方向光等）：
    - 计算漫反射、镜面反射、环境光等光照模型
    - 结合材质属性（如颜色、反射系数）
- **颜色合成：** 将光照结果与材质颜色结合，得到最终像素颜色。

### 2. 光源处理

- **逐像素光照：** 每个片段独立计算光照
- **多光源支持：** 需要为每个光源重复计算，增加计算量

---

## 三、前向渲染的优缺点

### 优点

- **简单直观：** 实现相对容易，适合初学者理解
- **支持透明效果：** 透明材质可以在渲染时正确处理
- **实时性能好：** 在光源数量较少的场景中表现良好

### 缺点

- **多光源性能瓶颈：** 每个光源都需要在每个片段中进行计算，光源数量多时效率下降
- **光照次数固定：** 不能灵活地在不同距离或物体上应用不同的光照效果
- **阴影和全局光照难以高效实现：** 需要额外的技术（如阴影贴图）来弥补

## 一、什么是延迟渲染

**定义：**

延迟渲染是一种“先几何后光照”的渲染技术。在渲染流程中，首先将场景中的几何信息（如位置、法线、颜色等）存储到多个缓冲区（G-buffer），然后在后续阶段对存储的几何数据进行光照计算。这样可以大大减少对光源数量增加时的性能影响。

**核心思想：**

- **几何阶段（G-buffer填充）：** 只负责存储场景的几何和材质信息到多个缓冲区。
- **光照阶段（Lighting Pass）：** 利用存储的几何信息，逐像素计算所有光源的光照并合成最终颜色。

---

## 二、延迟渲染的工作流程

### 1. 几何阶段（G-buffer填充）

- 逐个模型绘制，将各个像素的：
    - 位置（Position）
    - 法线（Normal）
    - 材质颜色（Albedo）
    - 粗糙度、镜面反射等信息
- 存储到多个不同的纹理（G-buffer）中。

### 2. 光照阶段（Lighting Pass）

- 使用存储的G-buffer信息，逐像素进行光照计算：
    - 计算场景中的每个光源对对应像素的贡献
    - 累加所有光源的光照效果
- 生成最终的场景图像。

### 3. 后处理（可选）

- 进行阴影、反射、抗锯齿等后续处理，完善最终图像。

---

## 三、延迟渲染的优缺点

### 优点

- **支持大量光源：** 光源的数量几乎没有性能影响，因为只在光照阶段处理，不影响几何绘制。
- **性能优势明显：** 在复杂场景中，减少对光源数量的性能瓶颈。
- **灵活性高：** 可以更方便地实现复杂的光照效果（如动态光源、多光源叠加等）。

### 缺点

- **对透明材质支持差：** 透明对象难以在延迟渲染中正确处理（需要特殊技术或结合前向渲染）。
- **内存开销大：** 需要额外存储多份G-buffer，耗费显存。
- **可能出现“光晕”或“鬼影”问题：** 在某些场景下需要额外处理（比如SSAO、阴影等）。
- **复杂的实现：** 需要多渲染目标（MRT）支持，技术实现比前向渲染复杂。

G-buffer缓存

### 一、G-buffer的定义

**G-buffer**是多个渲染目标（Render Targets）组成的缓冲区集合，每个缓冲区存储场景中每个像素对应的某种几何或材质信息。它在几何阶段（G-buffer填充阶段）被写入，在光照阶段（Lighting Pass）被读取，用于计算每个像素的最终颜色。

### 二、G-buffer的组成

典型的G-buffer包含以下内容的纹理（每个纹理对应一个缓冲区）：

1. **位置（Position）**
    
    存储每个像素在世界空间或视空间中的位置坐标。
    
    *作用：* 允许在光照阶段根据位置计算光源的影响。
    
2. **法线（Normal）**
    
    存储每个像素的表面法线向量。
    
    *作用：* 计算光照的反射、漫反射等。
    
3. **基础颜色（Albedo / Diffuse Color）**
    
    存储材质的基础颜色信息。
    
    *作用：* 作为最终颜色的基础。
    
4. **材质参数（如粗糙度、金属度等）**（可选）
    
    存储反射特性或其他材质信息，用于更真实的光照模型。
    
5. **其他信息（视需要）**
    
    比如软阴影的深度信息、特殊材质参数等。
    

### 三、G-buffer的工作流程

1. **几何阶段（G-buffer填充）**
    
    在场景中绘制模型时，将每个像素的几何和材质信息写入对应的G-buffer纹理中。这一阶段只负责存储，不进行光照计算。
    
2. **光照阶段（Lighting Pass）**
    
    利用存储的G-buffer信息，逐像素计算场景中所有光源的照明贡献，并合成最终颜色。
    

### 四、G-buffer的优势

- **支持大量光源：** 光照计算只在光照阶段进行，不影响几何渲染的复杂度。
- **灵活性高：** 可以在不同的光照条件或效果下反复使用存储的几何信息。
- **复杂光照效果：** 易于实现多光源、多材质的复杂光照模型。

### 五、G-buffer的缺点

- **内存开销大：** 需要存储多个纹理，占用大量显存。
- **透明材质难处理：** 透明对象在G-buffer中难以正确存储和处理。
- **实现复杂：** 需要支持多个渲染目标（MRT），并在后续阶段正确合成。

## 一、什么是Z-buffer（深度缓冲区）

**Z-buffer**，也称为深度缓冲区，是计算机图形学中用于管理场景中像素深度信息的一块缓冲存储区。它的主要作用是解决在三维场景渲染中“遮挡关系”的问题，确保场景中距离观察者较近的物体遮挡较远的物体。

---

## 二、Z-buffer的作用

在渲染过程中，当多个物体的像素投影到屏幕上时，可能会出现重叠。例如，前景的物体应遮挡住背景的物体。Z-buffer的作用就是记录每个像素的深度信息（距离观察点的距离），在渲染每个像素时，通过比较深度值，决定是否用当前像素的颜色覆盖之前的像素。

**简而言之：**

- 它确保了在二维屏幕上正确表现三维空间中的遮挡关系。

---

## 三、Z-buffer的工作原理

1. **初始化：** 在每一帧渲染开始时，将Z-buffer清空，通常为最大深度值（如1.0或无穷大）。
2. **渲染像素：**
    - 当绘制一个像素时，计算该像素的深度值（距离观察点的距离或深度值）。
    - 将该深度值与该像素当前位置存储的深度值进行比较。
3. **深度测试：**
    - 如果当前像素的深度值更接近观察者（即更小），则更新颜色缓冲区和Z-buffer中的深度值。
    - 如果更远，则丢弃当前像素，保持原有像素不变。

---

## 四、Z-buffer的存储内容

- **存储值：** 每个像素对应一个深度值（通常为浮点数或定点数），表示该位置上最接近观察者的物体的距离。

---

## 五、Z-buffer的优势

- **正确的遮挡关系：** 实现真实的三维场景深度效果。
- **效率高：** 硬件支持深度测试，性能较优。
- **简洁：** 只存储单一数值（深度值），实现简单。

---

## 六、Z-buffer的缺点和注意事项

- **Z-fighting（深度争用）：** 当两个表面非常接近时，可能出现闪烁和重影现象。解决方案包括调整深度精度或偏移。
- **精度问题：** 浮点深度值在某些场景下可能导致深度精度不足，影响遮挡效果。
- **额外开销：** 需要额外存储空间和硬件支持。
